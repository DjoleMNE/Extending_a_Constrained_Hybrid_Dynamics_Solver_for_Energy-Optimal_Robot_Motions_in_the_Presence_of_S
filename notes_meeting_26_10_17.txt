
Should we use the "absolute value" of acceleration (in Gauss formula)?
-> e.g. does the bias force have the same sign as the Cart. acceleration?
(This is theoretical energy, who knows does the sign of force influence change of energy)

Why is the input qdd not used? (s.A not used + commented qdd)

"In the last case, the constraint specification is non-conservative
(i.e., the
constraint forces do produce work (acceleration energy) against the
constraints)" [Azamat]
-> Should this acc. energy be included in Z?
(This will only  impose shifting)

// here sizeof(ff_torques) will give size of bits in memory == 0xbfebd5c0!!!!
void fun(double ff_torques[]) => void fun(double *ff_torques)

Default solver (KDL::Vereshchagin)

Kinematic chain

friction_enabled_vereshchagin
    Compute acc. energy
    Find optimal mu/friction torques

Simulation
-> Default solver
-> Friction-extended solver


class friction_enabled_vereshchagin
{
    friction_enabled_vereshchagin(KDL::Chain chain, const std::vector<double> &friction_torque) {
        friction_torque.resize(chain.getNrJoints());
    }

    void compute_acc_energy() {
        friction_torque.size()
    }

    void cart_to_jnt(q, qd, qdd, alpha, beta, extForces, tau) {
        moving_joints = f(qd);
        loop {
            tau_modified = tau + friction_torque;
            solver.CartToJnt(q, qd, qdd, alpha, beta, extForces, tau_modified);
        }
    }
};


class simulation
{
    void integrate() {
        ...
    }

    void step() {
        solver.cart_to_jnt();
        integrate(acc, vel);
    }

    void print_current_state()
    {
        ...
    }
};


int main()
{

    KDL::Chain a = create_my_kinematic_chain();
    friction_enabled_vereshchagin solver(a, break_away_torques);
    simulation s(a, solver);

    for i in 1:100:
        s.step()
        s.print_current_state()
}
