
Should we use the "absolute value" of acceleration (in Gauss formula)?
-> e.g. does the bias force have the same sign as the Cart. acceleration?
(This is theoretical energy, who knows does the sign of force influence change of energy)

Why is the input qdd not used? (s.A not used + commented qdd)

"In the last case, the constraint specification is non-conservative
(i.e., the
constraint forces do produce work (acceleration energy) against the
constraints)" [Azamat]
-> Should this acc. energy be included in Z?
(This will only  impose shifting)

// here sizeof(ff_torques) will give size of bits in memory == 0xbfebd5c0!!!!
void fun(double ff_torques[]) => void fun(double *ff_torques)

Default solver (KDL::Vereshchagin)
Kinematic chain
Compute acc. energy
Find optimal mu/friction torques
Simulation
-> Default solver
-> Friction-extended solver


void fun(double ff_torques[]) => void fun(double *ff_torques)


class KDL::Chain {
    kin
    dyn
    break_away_torque
};


void create_my_kinematic_chain(KDL::Chain &chain, std::vector<double>
&break_away_torques)
{
    return ...
};

class friction_enabled_vereshchagin
{
    friction_enabled_vereshchagin(KDL::Chain chain, std::vector<double>
break_away_torques) {
        friction_torque.resize(chain.getNrJoints());
    }

    void compute_acc_energy(const std::vector<double> &friction_torque) {
        friction_torque.size()
    }

    void cart_to_jnt(q, qd, qdd, alpha, beta, extForces, tau) {
        moving_joints = f(qd);
        loop {
            tau_modified = tau + friction_torque;
            solver.CartToJnt(q, qd, qdd, alpha, beta, extForces,
tau_modified);
            acc_energy = compute_acc_energy(friction_torque);
        }
    }
};


class simulation
{
    void integrate() {
        ...
    }

    void step() {
        solver.cart_to_jnt();
        integrate(acc, vel);
    }

    void print_current_state()
    {
        ...
    }
};


int main()
{
    KDL::Chain a = create_my_kinematic_chain();
    friction_enabled_vereshchagin solver(a);
    simulation s(a, solver);

    for i in 1:100:
        s.step()
        s.print_current_state()
}


solver_vereshchagin::getU(std::vector<double> &u)
{
    assert(u.size() == number_of_segments);
    for (int i = 0; i < number_of_segments; i++) {
        u[i] = results[i].U;
    }
}


Wrench f = sum_H[i] * segment_acceleration;
double e = dot(segment_acceleration, f);
